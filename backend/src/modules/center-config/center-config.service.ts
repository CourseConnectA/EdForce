import { Injectable, ForbiddenException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CenterFieldOption } from '../../database/entities/center-field-option.entity';
import { User } from '../../database/entities/user.entity';
import { normalizeRole } from '../../common/role.util';

// Global default options per dropdown field key
export const DEFAULT_DROPDOWN_OPTIONS: Record<string, string[]> = {
  gender: ['Male','Female','Other'],
  highestQualification: ['12th','Bachelor Degree','Master Degree','Doctorate'],
  yearsOfExperience: ['Still a student','Fresh Graduate','0-2 years','3-5 years','5-10 years','10+ years'],
  batch: ['Jan 2026','July 2026'],
  nationality: ['India','Bangladesh','Nepal','Sri Lanka','Other'],
  motherTongue: ['Hindi','English','Bengali','Tamil','Telugu','Marathi','Gujarati','Kannada','Malayalam','Odia','Punjabi','Urdu','Other'],
  locationState: ['Andhra Pradesh','Delhi','Gujarat','Karnataka','Maharashtra','Tamil Nadu','Telangana','Uttar Pradesh','West Bengal','Other'],
  locationCity: ['Bengaluru','Chennai','Delhi','Hyderabad','Kolkata','Mumbai','Pune','Ahmedabad','Lucknow','Jaipur','Other'],
  leadSource: ['Website','Referral','Walk-in','Call','Email','Social Media','Advertisement','Other'],
  leadSubSource: ['Google Ads','Facebook','Instagram','LinkedIn','Partner','Alumni','Event','Other'],
  createdFrom: ['Web','Mobile App','Import','API','Other'],
  program: ['MBA','BBA','M.Tech','B.Tech','Other'],
  specialization: ['Finance','Marketing','HR','IT','Operations','Other'],
  university: ['IIM','IIT','AIIMS','VTU','Anna University','Other'],
  yearOfCompletion: [], // generated by UI typically
  leadStatus: ['New','Assigned','In Process','Converted','Recycled','Dead'],
  leadSubStatus: ['Contacted','Follow-up Scheduled','Interview Scheduled','Offer Made','Enrolled','Dead','Invalid'],
};

@Injectable()
export class CenterConfigService {
  constructor(
    @InjectRepository(CenterFieldOption) private optsRepo: Repository<CenterFieldOption>,
    @InjectRepository(User) private usersRepo: Repository<User>,
  ) {}

  getDefaultOptions(): Record<string, string[]> {
    return DEFAULT_DROPDOWN_OPTIONS;
  }

  async listCenters(search?: string) {
    const qb = this.usersRepo.createQueryBuilder('u')
      .select('DISTINCT u.center_name', 'centerName')
      .where("u.center_name IS NOT NULL AND u.center_name != ''")
      .andWhere('u.deleted = :del', { del: false });
    if (search) {
      qb.andWhere('LOWER(u.center_name) LIKE LOWER(:q)', { q: `%${search}%` });
    }
  // Order by the actual column to avoid Postgres alias case folding issues observed in some environments
  const rows = await qb.orderBy('u.center_name', 'ASC').getRawMany<{ centerName: string }>();
    return rows.map(r => ({ centerName: r.centerName }));
  }

  async getEffectiveOptionsForCenter(centerName: string) {
    const defaults = this.getDefaultOptions();
    const overrides = await this.optsRepo.find({ where: { centerName } as any });
    const map: Record<string, string[]> = { ...defaults };
    for (const ov of overrides) {
      map[ov.fieldKey] = Array.isArray(ov.options) ? ov.options : [];
    }
    return map;
  }

  async getOptionsForUserCenter(user: any) {
    const role = normalizeRole(user?.role, user?.isAdmin);
    const centerName = user?.centerName || null;
    if (!centerName) {
      // No center; just return defaults
      return this.getDefaultOptions();
    }
    return this.getEffectiveOptionsForCenter(centerName);
  }

  async upsertOptions(centerName: string, fieldKey: string, options: string[]) {
    // Empty or undefined options revert to default => delete override
    const clean = Array.isArray(options) ? options.map(s => String(s).trim()).filter(Boolean) : [];
    const existing = await this.optsRepo.findOne({ where: { centerName, fieldKey } as any });
    if (!clean.length) {
      if (existing) await this.optsRepo.remove(existing);
      return { centerName, fieldKey, options: null, revertedToDefault: true };
    }
    if (existing) {
      existing.options = clean;
      await this.optsRepo.save(existing);
      return existing;
    }
    const created = this.optsRepo.create({ centerName, fieldKey, options: clean });
    return this.optsRepo.save(created);
  }
}
